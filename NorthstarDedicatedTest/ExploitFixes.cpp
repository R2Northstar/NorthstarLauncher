// clang-format off
#include "pch.h"

#include "ExploitFixes.h"
#include "KittenMemUtils.h"

// Make sure 3 or less floats are valid
bool ValidateFloats(float a, float b = 0, float c = 0) {
	return !isnan(a) && !isnan(b) && !isnan(c);
}

struct Vector {
	float x, y, z;

	Vector(float x = 0, float y = 0, float z = 0) : x(x), y(y), z(z) {}

	bool IsValid() {
		return ValidateFloats(x, y, z);
	}
};

struct Angle {
	float pitch, yaw, roll;

	Angle(float pitch = 0, float yaw = 0, float roll = 0) : pitch(pitch), yaw(yaw), roll(roll) {}

	bool IsInvalid() {
		if (!ValidateFloats(pitch, yaw, roll))
			return false;

		return
			(pitch > 90 || pitch < -90)
			|| (yaw > 180 || yaw < -180)
			|| (roll > 180 || roll < -180);
	}
};

#define BLOCK_NETMSG_FUNC(name, pattern) \
	KHOOK(name, ("engine.dll", pattern), bool, __fastcall, (void* thisptr, void* buffer)) { return false; }

// Servers can literally request a screenshot from any client, yeah no
BLOCK_NETMSG_FUNC(CLC_Screenshot_WriteToBuffer, "48 89 5C 24 ? 57 48 83 EC 20 8B 42 10");
BLOCK_NETMSG_FUNC(CLC_Screenshot_ReadFromBuffer, "48 89 5C 24 ? 48 89 6C 24 ? 48 89 74 24 ? 57 48 83 EC 20 48 8B DA 48 8B 52 38");

// This is unused ingame and a big exploit vector
BLOCK_NETMSG_FUNC(Base_CmdKeyValues_ReadFromBuffer, "40 55 48 81 EC ? ? ? ? 48 8D 6C 24 ? 48 89 5D 70");

// Purpose: prevent invalid user CMDs
KHOOK(CClient_ProcessUsercmds, ("engine.dll", "40 55 56 48 83 EC 58"), bool, __fastcall, (void* thisptr, void* pMsg)) {
	struct __declspec(align(8)) CLC_Move {
		BYTE gap0[24];
		void* m_pMessageHandler;
		int m_nBackupCommands;
		int m_nNewCommands;
		int m_nLength;
		// bf_read m_DataIn;
		// bf_write m_DataOut;
	};

	auto msg = (CLC_Move*)pMsg;

	if (msg->m_nBackupCommands < 0 || msg->m_nNewCommands < 1)
		return false; // Nice try buster

	constexpr int NUMCMD_SANITY_LIMIT = 16;
	if ((msg->m_nNewCommands + msg->m_nBackupCommands) > NUMCMD_SANITY_LIMIT)
		return false; // Im good

	if (msg->m_nLength <= 0)
		return false;

	return oCClient_ProcessUsercmds(thisptr, pMsg);
}

KHOOK(ReadUsercmd, ("server.dll", "4C 89 44 24 ? 53 55 56 57"), void, __fastcall, (void* buf, void* pCmd_move, void* pCmd_from)) {
	// Let normal usercmd read happen first, it's safe
	oReadUsercmd(buf, pCmd_move, pCmd_from);

	// Now let's make sure the CMD we read isnt messed up to prevent numerous exploits (including server crashing)
	struct __declspec(align(4)) SV_CUserCmd
	{
		DWORD command_number;
		DWORD tick_count;
		float command_time;
		Angle worldViewAngles;
		BYTE gap18[4];
		Angle localViewAngles;
		Angle attackangles;
		Vector move;
		DWORD buttons;
		BYTE impulse;
		short weaponselect;
		DWORD meleetarget;
		BYTE gap4C[24];
		char headoffset;
		BYTE gap65[11];
		Vector cameraPos;
		Angle cameraAngles;
		BYTE gap88[4];
		int tickSomething;
		DWORD dword90;
		DWORD predictedServerEventAck;
		DWORD dword98;
		float frameTime;
	};
	auto cmd = (SV_CUserCmd*)pCmd_move;

	if (
		cmd->worldViewAngles.IsInvalid() ||
		cmd->localViewAngles.IsInvalid() ||
		cmd->attackangles.IsInvalid() ||
		cmd->cameraAngles.IsInvalid()) {
		goto INVALID_CMD;
	}

	if (cmd->frameTime <= 0 || cmd->tick_count == 0 || cmd->command_time <= 0)
		goto INVALID_CMD; // No simulation of bogus-timed cmds

	if (!cmd->move.IsValid() || // Prevent player freeze (and even server crash) exploit
		!cmd->cameraPos.IsValid()) // IIRC this can crash spectating clients or anyone watching replays
		goto INVALID_CMD; 

	if (!ValidateFloats(cmd->cameraPos.x, cmd->cameraPos.y, cmd->cameraPos.z))
		goto INVALID_CMD; // IIRC this can crash spectating clients or anyone watching replays

	return;
INVALID_CMD:

	// Fix any gameplay-affecting cmd properties
	// NOTE: Currently tickcount/frametime is set to 0, this ~shouldn't~ cause any problems
	cmd->worldViewAngles = cmd->localViewAngles = cmd->attackangles = cmd->cameraAngles = Angle(0,0,0);
	cmd->tick_count = cmd->frameTime = 0;
	cmd->move = cmd->cameraPos = Vector(0, 0, 0);
	cmd->buttons = 0;
	cmd->meleetarget = 0;
}

void ExploitFixes::LoadCallback(HMODULE unused) {
	spdlog::info("ExploitFixes::LoadCallback ...");
	if (KHook::InitAllHooks() && false) {
		spdlog::info("\tInitialized " + std::to_string(KHook::_allHooks.size()) + " exploit-patch hooks.");
	} else {
		spdlog::critical("\tFAILED to initialize all exploit patches.");
		
		// Force exit?
		MessageBoxA(0, "FAILED to initialize all exploit patches.", "Northstar", MB_ICONERROR);
		exit(0);
	}
}